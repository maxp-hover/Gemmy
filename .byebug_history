exit-program
{}.persisted "#{CachePath}/#{db_name}.yaml"
Dir.exists? CachePath
CachePath
continue
@db
next
home
continue
NounLexicon
exit-program
@lexicon_set_up
next
@lexicon_set_up
exit-program
NounLexicon
exit-program
Object::NounLexicon
NounLexicon
NounLexicon[:a][:b] = 1
NounLexicon
NounLexicon.class
NounLexicon.get
NounLexicon
exit-program
`echo "$HOME"`
`"$HOME"`
`ls ~/gemmy`
Dir.exists? CachePath
CachePath
exit-program
`ls $HOME`
CachePath
CachePatch
`ls ~/gemmy`
`mkdir -p #{CachePath}`
Dir.exists?CachePath
`ls #{CachePath}`
CachePath
exit-program
Gemmy.patch "hash/u/persisted"
{}.persisted
continue
Gem.find_files("gemmy/patches/*.rb")
Gem.find_files("components/cache.rb")
Gem.find_files("components/cache.rb
Gem.find_files("gemmy/**/cache.rb")
Gem.find_files("gemmy/**/*.rb")
exit-program
`wordpos def thought`
exit-program
wordpos_lookup "islands"
wordpos_lookip "islands"
doublecheck
next
sentence
next; "#{word} #{pos}"
next; word
word
next
pos
word
continue
pos
nextword
pos
next
pos
word
next
doublecheck
next
pos
word
next
doublecheck
next
pos
word
exit-program
pos
word
continue
pos
word
exit-program
continue
next
word
next
pos
exit-program
(pos.include? "verb") && !doublecheck.include?("noun")
pos.include? "verb" && !doublecheck.include?("noun")
!doublecheck.include?("noun")
doublecheck.include?("noun")
!doublecheck.include?("noun")
pos.include? "verb"# && !doublecheck.include?("noun")
pos.include? "verb" && !doublecheck.include?("noun")
pos.include? "noun" && !doublecheck.include?("verb")
exit-program
up
doublecheck
pos.include? "verb"
next
doublecheck
word
pos
exit-program
pos
continue
word
pos
next
pos
wordpos_doublecheck
next
pos
word
exit-program
res
continue
self
continue
self
exit-program
continue
SentenceInterpreter.interpret sentence
continue
self[0]
self
continue
class Array
1.method :asd
EngTagger.new.get_nouns EngTagger.new.add_tags(sentence)
sentence = "Eat cat, and rat"
EngTagger.new.get_nouns EngTagger.new.add_tags(sentence)
EngTagger.new.get_verbs EngTagger.new.add_tags(sentence)
EngTagger.new.add_tags(sentence)
sentence = "twas, truthful"
sentence
@tagger.get_verbs tagged
@tagger.get_verbs
nouns
exit-program
JSON.parse pos_response
pos_response
exit-program
JSON.parse "{\"nouns\":[],\"verbs\":[],\"adjectives\":[],\"adverbs\":[],\"rest\":[\"2s\",\"\"]}"
JSON.parse '{\"nouns\":[],\"verbs\":[],\"adjectives\":[],\"adverbs\":[],\"rest\":[\"2s\",\"\"]}'
JSON.parse pos_response
pos_response
exit-program
continue
`coffee -e "#{Gemmy::Coffee}" pos 'face'`
`coffee -e "#{Gemmy::Coffee}"`
exit-program
continue
`coffee -e "require 'wordpos'"`
`coffee #{Gemmy::Coffee.tempfile_path} pos "asd"`
`coffee #{Gemmy::Coffee.tempfile_path}`
exit-program
`ls ~/node_modules/wordpos/bin`
`ls ~/node_modules/wordpos`
`ls ~/node_modules`
`ls ~/.node_modules`
`ls node_modules`
`coffee #{t} pos "asd"`
`coffee #{t} foo 1`
`coffee #{t}`
t
system_command "coffee #{t} pos 'my name is what'"
t = Gemmy::Coffee.tempfile_path
system_command "coffee #{t} pos 'my name is what'"
t = Gemmy::Coffee.tempfile_path
exit-program
system_command "coffee #{t} pos 'my name is what'"
t = Gemmy::Coffee.tempfile_path
exit-program
system_command "coffee #{t} pos 'my name is what'"
t = Gemmy::Coffee.tempfile_path
exit-program
continue
system_command "coffee #{t} pos 'my name is what'"
system_command "coffee #{t} pos "my name is what""
t = Gemmy::Coffee.tempfile_path
system_command "coffee #{t} pos 'my name is what'"
system_command "coffee #{t} pos "my name is what""
continue
`coffee #{t} pos "my name is what"`
t = Gemmy::Coffee.tempfile_path
exit-program
continue
`coffee #{t} pos "my name is what"`
t = Gemmy::Coffee.tempfile_path
exit-program
continue
`coffee #{t} pos "my name is what"`
`coffee #{t}`
File.read(t).length
t
t.
t = Gemmy::Coffee.tempfile_path
Gemmy::Coffee.tempfile_path
exit-program
continue
Gemmy::Coffee.tempfile_path
Gemmy::Coffee.to_tempfile
exit-program
File.read t.path
t.path
File.read t.path
File.read _
t.path
t.close
t.cofe
t.write "asd"
t = Tempfile.new
Tempfile.new
Gemmy::Coffee.length
exit-program
continue
Gemmy::Coffee
continue
1.deep_copy
{}.deep_copy
{}.deep_clone
Marshal.dump ({}.persisted "foo")
Marshal.dump ({}.persisted)
Marshal.dump {}.persisted
YAML::Store.new "pos_cache.pstore"
a
a = {}.persisted "pos_cache.pstore"
{}.persisted "pos_cache.pstore"
continue
@db
continue
@db
continue
@db
continue
@db
continue
@db
@db.set *keys, blk.call
db.set *keys, blk.call
blk.call
result
@db
continue
@db
exit-program
@db.get "eat"
@db.set "eat", 1
@db.fetch "eat"
@db.keys
