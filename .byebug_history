continue
[].to_enum.map_by
continue
Gemmy::Patches::SymbolPatch::InstanceMethods::Call._call
self
continue
module Test
"".strip_heredoc
CF
[1, 2, 3].extract_options!
[].extract_options!
[].extract_options
{a:1, b:2}.extract_options!
continue
[1,2,3].key_by { |v| v % 2 }
[1,1,2,3].key_by { |v| v % 2 }
continue
h[1]
h
h[1].push 1
h[1]
h[1] << 1
h[1]
 h = Hash.new { |k,v| v = [] }
[1,1,2,3].key_by { |v| v % 2 }
continue
[1,1,2,3].key_by { |v| v % 2 }
continue
[1,1,2,3].key_by { |v| v % 2 }
1 % 2
[1,2,3].key_by { |v| v % 2 }
continue
Array.zip([1], [2])
Array.wrap [1]
Array.wrap 1
Array.wrap []
Array.wrap nil
continue
        Array.wrap(nil)
continue
CF::Support.classes_including_modules(nil)
CF::Support.classes_including_modules
super
exit-program
patch_klass.refine
patch_klass
core_klass
continue
Array.class
Enumerable.class
patch_klass.send(:refine, core_klass) { }
patch_klass.class
core_klass.class
patch_klass
core_klass
e
continue
[1,2,3].each &(arr.method(:push).bind("and"))
arr = []
continue
[1,2,3].each &arr.method(:push).bind("and")
arr = []
continue
[1,2,3].each &arr.method(:push).bind("and")
arr = []
continue
[].push([],[])
[].concat([],[])
a.concat([], []_
1.+(1,2)
1.method(:+)
1.method(:add)
Integer.method(:add)
a = (&:add)
(&:add)
method(:add)
[1,2,3].class
[1,2,3]
continue
StringIO.send :gets
StringIO.gets
StringIO
continue
Kernel.gets
Kernel
continue
ARGV
gets
next
ARGV
continue
patch_types
hash
type_sym
type_sym\
continue
Gemmy::Patches::HashPatch::InstanceMethods::Autovivified._autovivified
continue
self.class
self
Gemmy::Patches::HashPatch::InstanceMethods::Autovivified._autovivified self
continue
Gemmy::Patches::HashPatch::InstanceMethods::Autovivified._autovivified
Gemmy::Patches::HashPatch::InstanceMethods::Autovivified
continue
core_klass_sym
Object.const_get core_klass_sym.to_s
const_get core_klass_sym.to_s
self
continue
Gemmy::Patches.class_refinements
continue
 instance_classes.const_get klass_sym
klass_sym
continue
patch_class
continue
"".unindent
""unindent
[].any_not?
[].any_not
next
continue
Gemmy::Patches.class_refinements
continue
Gemmy::Patches.class_refinements
exit-program
continue
using patch_klass
"".unindent
patch_klass
patch_klass.send(:refine, const_get(core_klass)) { include patch_klass }
patch_klass.send(:refine, const_get(core_klass)) { |x| puts(x.class) }
patch_klass.send(:refine, const_get(core_klass)) { |x| puts(x) }
patch_klass.send(:refine, const_get(core_klass)) { |x| puts(x); }
patch_klass.send(:refine, const_get(core_klass)) { |x| puts(x); puts(x) }
patch_klass.send(:refine, const_get(core_klass)) { |x| puts x; puts x }
patch_klass.send(:refine, const_get(core_klass)) { |x| puts x }
patch_klass.send(:refine, const_get(core_klass))
patch_klass.send(:refine)
patch_klass.refine
patch_klass
core_klass
continue
self
define_step
include Gemmy::Components
self
continue
hash
hash.set(:a, :b, 0)
hash
hash.get :a, :b
continue
caller
{}.bury
Hash.include Gemmy::Patches::HashPatch
{}.bury
Hash.extend Gemmy::Patches::HashPatch
self.class
Hash.extend self.class
continue
{}.bury
continue
self.class
self
send(:bury)
{}.bury
method(:bury)
__callee__
__method__
continue
__callee__
__method__
continue
hash.bury
continue
"".nothing
Object.new.method(:nothing)
Object.method(:nothing)
[].any_not?
continue
Gemmy::Patches.list.values.each { |x| using x }
using Gemmy::Patches.list.values[0]
Gemmy::Patches.list.values
Gemmy::Patches.list
continue
self.class.class_exec { "".unindent }
self.class::String.new.unindent
self.class::String
self.class::String = Gemmy::Patches::StringPatch
self.class.class_exec { "".unindent }
self.class_exec
self.class::Thread == Gemmy::Patches::ThreadPatch
Thread == Gemmy::Patches::ThreadPatch
Thread
Thread.class
self.class::Thread = Gemmy::Patches::ThreadPatch
self::Thread
self.class::Array
Array
[].any_not?
continue
 match_results.any_not?
String == Object::String
self.class.const_set("String", String.clone)
String == Object::String
String
continue
self.class::String
self.class
exit-program
continue
a.unindent
a.singleton_class.prepend patch_klass
a.singleton_class
a = String.new
a.unindent
a.extend patch_klass
a = String.new
a = Array.new
Asd.new
b = Asd.new
Asd.new
Asd = Class.new
b = A.new
A = Class.new
b = a.new
a = Class.new
patch_klass
base.class_exec { "".unindent }
base.extend patch_klass
base.class_exec { "".unindent }
base.include patch_klass
base.class_exec { "".unindent }
base.prepend patch_klass
base.class
base
continue
self
match_results.any_not?
continue
a.class
a.send :using, patch_klass
a.using
a = Class.new
base
base.send(:using, patch_klass)
base.using
base
continue
self.class
self.class.constants
self
"asd".unindent
continue
